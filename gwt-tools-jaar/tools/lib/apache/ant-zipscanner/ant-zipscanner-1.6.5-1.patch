diff --git org/apache/tools/ant/BuildException.java org/apache/tools/ant/BuildException.java
index 13a528e..3e36985 100644
--- org/apache/tools/ant/BuildException.java
+++ org/apache/tools/ant/BuildException.java
@@ -28,8 +28,8 @@ public class BuildException extends RuntimeException {
     /** Exception that might have caused this one. */
     private Throwable cause;
 
-    /** Location in the build file where the exception occurred */
-    private Location location = Location.UNKNOWN_LOCATION;
+//    /** Location in the build file where the exception occurred */
+//    private Location location = Location.UNKNOWN_LOCATION;
 
     /**
      * Constructs a build exception with no descriptive information.
@@ -62,21 +62,21 @@ public class BuildException extends RuntimeException {
         this.cause = cause;
     }
 
-    /**
-     * Constructs an exception with the given message and exception as
-     * a root cause and a location in a file.
-     *
-     * @param msg A description of or information about the exception.
-     *            Should not be <code>null</code> unless a cause is specified.
-     * @param cause The exception that might have caused this one.
-     *              May be <code>null</code>.
-     * @param location The location in the project file where the error
-     *                 occurred. Must not be <code>null</code>.
-     */
-    public BuildException(String msg, Throwable cause, Location location) {
-        this(msg, cause);
-        this.location = location;
-    }
+//    /**
+//     * Constructs an exception with the given message and exception as
+//     * a root cause and a location in a file.
+//     *
+//     * @param msg A description of or information about the exception.
+//     *            Should not be <code>null</code> unless a cause is specified.
+//     * @param cause The exception that might have caused this one.
+//     *              May be <code>null</code>.
+//     * @param location The location in the project file where the error
+//     *                 occurred. Must not be <code>null</code>.
+//     */
+//    public BuildException(String msg, Throwable cause, Location location) {
+//        this(msg, cause);
+//        this.location = location;
+//    }
 
     /**
      * Constructs an exception with the given exception as a root cause.
@@ -89,33 +89,33 @@ public class BuildException extends RuntimeException {
         this.cause = cause;
     }
 
-    /**
-     * Constructs an exception with the given descriptive message and a
-     * location in a file.
-     *
-     * @param message A description of or information about the exception.
-     *            Should not be <code>null</code>.
-     * @param location The location in the project file where the error
-     *                 occurred. Must not be <code>null</code>.
-     */
-    public BuildException(String message, Location location) {
-        super(message);
-        this.location = location;
-    }
-
-    /**
-     * Constructs an exception with the given exception as
-     * a root cause and a location in a file.
-     *
-     * @param cause The exception that might have caused this one.
-     *              Should not be <code>null</code>.
-     * @param location The location in the project file where the error
-     *                 occurred. Must not be <code>null</code>.
-     */
-    public BuildException(Throwable cause, Location location) {
-        this(cause);
-        this.location = location;
-    }
+//    /**
+//     * Constructs an exception with the given descriptive message and a
+//     * location in a file.
+//     *
+//     * @param message A description of or information about the exception.
+//     *            Should not be <code>null</code>.
+//     * @param location The location in the project file where the error
+//     *                 occurred. Must not be <code>null</code>.
+//     */
+//    public BuildException(String message, Location location) {
+//        super(message);
+//        this.location = location;
+//    }
+//
+//    /**
+//     * Constructs an exception with the given exception as
+//     * a root cause and a location in a file.
+//     *
+//     * @param cause The exception that might have caused this one.
+//     *              Should not be <code>null</code>.
+//     * @param location The location in the project file where the error
+//     *                 occurred. Must not be <code>null</code>.
+//     */
+//    public BuildException(Throwable cause, Location location) {
+//        this(cause);
+//        this.location = location;
+//    }
 
     /**
      * Returns the nested exception, if any.
@@ -137,33 +137,33 @@ public class BuildException extends RuntimeException {
         return getException();
     }
 
-    /**
-     * Returns the location of the error and the error message.
-     *
-     * @return the location of the error and the error message
-     */
-    public String toString() {
-        return location.toString() + getMessage();
-    }
-
-    /**
-     * Sets the file location where the error occurred.
-     *
-     * @param location The file location where the error occurred.
-     *                 Must not be <code>null</code>.
-     */
-    public void setLocation(Location location) {
-        this.location = location;
-    }
-
-    /**
-     * Returns the file location where the error occurred.
-     *
-     * @return the file location where the error occurred.
-     */
-    public Location getLocation() {
-        return location;
-    }
+//    /**
+//     * Returns the location of the error and the error message.
+//     *
+//     * @return the location of the error and the error message
+//     */
+//    public String toString() {
+//        return location.toString() + getMessage();
+//    }
+
+//    /**
+//     * Sets the file location where the error occurred.
+//     *
+//     * @param location The file location where the error occurred.
+//     *                 Must not be <code>null</code>.
+//     */
+//    public void setLocation(Location location) {
+//        this.location = location;
+//    }
+//
+//    /**
+//     * Returns the file location where the error occurred.
+//     *
+//     * @return the file location where the error occurred.
+//     */
+//    public Location getLocation() {
+//        return location;
+//    }
 
     /**
      * Prints the stack trace for this exception and any
diff --git org/apache/tools/ant/DirectoryScanner.java org/apache/tools/ant/DirectoryScanner.java
index 0bf8267..dd5a7c1 100644
--- org/apache/tools/ant/DirectoryScanner.java
+++ org/apache/tools/ant/DirectoryScanner.java
@@ -31,10 +31,9 @@ import java.util.Enumeration;
 
 import org.apache.tools.ant.taskdefs.condition.Os;
 import org.apache.tools.ant.types.Resource;
-import org.apache.tools.ant.types.ResourceFactory;
-import org.apache.tools.ant.types.selectors.FileSelector;
+//import org.apache.tools.ant.types.ResourceFactory;
+//import org.apache.tools.ant.types.selectors.FileSelector;
 import org.apache.tools.ant.types.selectors.SelectorUtils;
-import org.apache.tools.ant.types.selectors.SelectorScanner;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
@@ -121,7 +120,7 @@ import org.apache.tools.ant.util.FileUtils;
  *
  */
 public class DirectoryScanner
-       implements FileScanner, SelectorScanner, ResourceFactory {
+       /*implements FileScanner, SelectorScanner, ResourceFactory*/ {
 
     /** Is OpenVMS the operating system we're running on? */
     private static final boolean ON_VMS = Os.isFamily("openvms");
@@ -193,8 +192,8 @@ public class DirectoryScanner
     /** The patterns for the files to be excluded. */
     protected String[] excludes;
 
-    /** Selectors that will filter which files are in our candidate list. */
-    protected FileSelector[] selectors = null;
+//    /** Selectors that will filter which files are in our candidate list. */
+//    protected FileSelector[] selectors = null;
 
     /**
      * The files which matched at least one include and no excludes
@@ -720,14 +719,14 @@ public class DirectoryScanner
         return pattern;
     }
 
-    /**
-     * Set the selectors that will select the filelist.
-     *
-     * @param selectors specifies the selectors to be invoked on a scan.
-     */
-    public synchronized void setSelectors(FileSelector[] selectors) {
-        this.selectors = selectors;
-    }
+//    /**
+//     * Set the selectors that will select the filelist.
+//     *
+//     * @param selectors specifies the selectors to be invoked on a scan.
+//     */
+//    public synchronized void setSelectors(FileSelector[] selectors) {
+//        this.selectors = selectors;
+//    }
 
     /**
      * Return whether or not the scanner has included all the files or
@@ -1272,13 +1271,13 @@ public class DirectoryScanner
      *         should not be selected, <code>true</code> otherwise.
      */
     protected boolean isSelected(String name, File file) {
-        if (selectors != null) {
-            for (int i = 0; i < selectors.length; i++) {
-                if (!selectors[i].isSelected(basedir, name, file)) {
-                    return false;
-                }
-            }
-        }
+//        if (selectors != null) {
+//            for (int i = 0; i < selectors.length; i++) {
+//                if (!selectors[i].isSelected(basedir, name, file)) {
+//                    return false;
+//                }
+//            }
+//        }
         return true;
     }
 
diff --git org/apache/tools/ant/taskdefs/condition/Os.java org/apache/tools/ant/taskdefs/condition/Os.java
index 1e862d8..63fa75d 100644
--- org/apache/tools/ant/taskdefs/condition/Os.java
+++ org/apache/tools/ant/taskdefs/condition/Os.java
@@ -25,7 +25,7 @@ import org.apache.tools.ant.BuildException;
  *
  * @since Ant 1.4
  */
-public class Os implements Condition {
+public class Os /*implements Condition*/ {
     private static final String OS_NAME =
         System.getProperty("os.name").toLowerCase(Locale.US);
     private static final String OS_ARCH =
@@ -35,10 +35,10 @@ public class Os implements Condition {
     private static final String PATH_SEP =
         System.getProperty("path.separator");
 
-    private String family;
-    private String name;
-    private String version;
-    private String arch;
+//    private String family;
+//    private String name;
+//    private String version;
+//    private String arch;
 
     /**
      * Default constructor
@@ -47,72 +47,72 @@ public class Os implements Condition {
     public Os() {
     }
 
-    /**
-     * Constructor that sets the family attribute
-     *
-     * @param family a String value
-     */
-    public Os(String family) {
-        setFamily(family);
-    }
-
-    /**
-     * Sets the desired OS family type
-     *
-     * @param f      The OS family type desired<br />
-     *               Possible values:<br />
-     *               <ul>
-     *               <li>dos</li>
-     *               <li>mac</li>
-     *               <li>netware</li>
-     *               <li>os/2</li>
-     *               <li>tandem</li>
-     *               <li>unix</li>
-     *               <li>windows</li>
-     *               <li>win9x</li>
-     *               <li>z/os</li>
-     *               <li>os/400</li>
-     *               </ul>
-     */
-    public void setFamily(String f) {
-        family = f.toLowerCase(Locale.US);
-    }
-
-    /**
-     * Sets the desired OS name
-     *
-     * @param name   The OS name
-     */
-    public void setName(String name) {
-        this.name = name.toLowerCase(Locale.US);
-    }
-
-    /**
-     * Sets the desired OS architecture
-     *
-     * @param arch   The OS architecture
-     */
-    public void setArch(String arch) {
-        this.arch = arch.toLowerCase(Locale.US);
-    }
-
-    /**
-     * Sets the desired OS version
-     *
-     * @param version   The OS version
-     */
-    public void setVersion(String version) {
-        this.version = version.toLowerCase(Locale.US);
-    }
-
-    /**
-     * Determines if the OS on which Ant is executing matches the type of
-     * that set in setFamily.
-     * @see Os#setFamily(String)
-     */
-    public boolean eval() throws BuildException {
-        return isOs(family, name, arch, version);
-    }
+//    /**
+//     * Constructor that sets the family attribute
+//     *
+//     * @param family a String value
+//     */
+//    public Os(String family) {
+//        setFamily(family);
+//    }
+
+//    /**
+//     * Sets the desired OS family type
+//     *
+//     * @param f      The OS family type desired<br />
+//     *               Possible values:<br />
+//     *               <ul>
+//     *               <li>dos</li>
+//     *               <li>mac</li>
+//     *               <li>netware</li>
+//     *               <li>os/2</li>
+//     *               <li>tandem</li>
+//     *               <li>unix</li>
+//     *               <li>windows</li>
+//     *               <li>win9x</li>
+//     *               <li>z/os</li>
+//     *               <li>os/400</li>
+//     *               </ul>
+//     */
+//    public void setFamily(String f) {
+//        family = f.toLowerCase(Locale.US);
+//    }
+
+//    /**
+//     * Sets the desired OS name
+//     *
+//     * @param name   The OS name
+//     */
+//    public void setName(String name) {
+//        this.name = name.toLowerCase(Locale.US);
+//    }
+
+//    /**
+//     * Sets the desired OS architecture
+//     *
+//     * @param arch   The OS architecture
+//     */
+//    public void setArch(String arch) {
+//        this.arch = arch.toLowerCase(Locale.US);
+//    }
+
+//    /**
+//     * Sets the desired OS version
+//     *
+//     * @param version   The OS version
+//     */
+//    public void setVersion(String version) {
+//        this.version = version.toLowerCase(Locale.US);
+//    }
+
+//    /**
+//     * Determines if the OS on which Ant is executing matches the type of
+//     * that set in setFamily.
+//     * @see Os#setFamily(String)
+//     */
+//    public boolean eval() throws BuildException {
+//        return isOs(family, name, arch, version);
+//    }
 
     /**
      * Determines if the OS on which Ant is executing matches the
@@ -125,41 +125,41 @@ public class Os implements Condition {
         return isOs(family, null, null, null);
     }
 
-    /**
-     * Determines if the OS on which Ant is executing matches the
-     * given OS name.
-     *
-     * @param name the OS name to check for
-     * @return true if the OS matches
-     * @since 1.7
-     */
-    public static boolean isName(String name) {
-        return isOs(null, name, null, null);
-    }
-
-    /**
-     * Determines if the OS on which Ant is executing matches the
-     * given OS architecture.
-     *
-     * @param arch the OS architecture to check for
-     * @return true if the OS matches
-     * @since 1.7
-     */
-    public static boolean isArch(String arch) {
-        return isOs(null, null, arch, null);
-    }
-
-    /**
-     * Determines if the OS on which Ant is executing matches the
-     * given OS version.
-     *
-     * @param version the OS version to check for
-     * @return true if the OS matches
-     * @since 1.7
-     */
-    public static boolean isVersion(String version) {
-        return isOs(null, null, null, version);
-    }
+//    /**
+//     * Determines if the OS on which Ant is executing matches the
+//     * given OS name.
+//     *
+//     * @param name the OS name to check for
+//     * @return true if the OS matches
+//     * @since 1.7
+//     */
+//    public static boolean isName(String name) {
+//        return isOs(null, name, null, null);
+//    }
+
+//    /**
+//     * Determines if the OS on which Ant is executing matches the
+//     * given OS architecture.
+//     *
+//     * @param arch the OS architecture to check for
+//     * @return true if the OS matches
+//     * @since 1.7
+//     */
+//    public static boolean isArch(String arch) {
+//        return isOs(null, null, arch, null);
+//    }
+
+//    /**
+//     * Determines if the OS on which Ant is executing matches the
+//     * given OS version.
+//     *
+//     * @param version the OS version to check for
+//     * @return true if the OS matches
+//     * @since 1.7
+//     */
+//    public static boolean isVersion(String version) {
+//        return isOs(null, null, null, version);
+//    }
 
     /**
      * Determines if the OS on which Ant is executing matches the
diff --git org/apache/tools/ant/types/Resource.java org/apache/tools/ant/types/Resource.java
index 250e699..6b743e4 100644
--- org/apache/tools/ant/types/Resource.java
+++ org/apache/tools/ant/types/Resource.java
@@ -124,13 +124,13 @@ public class Resource implements Cloneable, Comparable {
         this.name = name;
     }
 
-    /**
-     * The exists attribute tells whether a file exists.
-     * @return true if this resource exists.
-     */
-    public boolean isExists() {
-        return exists;
-    }
+//    /**
+//     * The exists attribute tells whether a file exists.
+//     * @return true if this resource exists.
+//     */
+//    public boolean isExists() {
+//        return exists;
+//    }
 
     /**
      * Set the exists attribute.
@@ -183,15 +183,15 @@ public class Resource implements Cloneable, Comparable {
         this.size = (size > UNKNOWN_SIZE) ? size : UNKNOWN_SIZE;
     }
 
-    /**
-     * Get the size of this Resource.
-     * @return the size, as a long, 0 if the Resource does not exist (for
-     *         compatibility with java.io.File), or UNKNOWN_SIZE if not known.
-     * @since Ant 1.6.3
-     */
-    public long getSize() {
-        return (exists) ? size : 0L;
-    }
+//    /**
+//     * Get the size of this Resource.
+//     * @return the size, as a long, 0 if the Resource does not exist (for
+//     *         compatibility with java.io.File), or UNKNOWN_SIZE if not known.
+//     * @since Ant 1.6.3
+//     */
+//    public long getSize() {
+//        return (exists) ? size : 0L;
+//    }
 
     /**
      * Clone this Resource.
diff --git org/apache/tools/ant/types/selectors/SelectorUtils.java org/apache/tools/ant/types/selectors/SelectorUtils.java
index 7483d8b..ad28f52 100644
--- org/apache/tools/ant/types/selectors/SelectorUtils.java
+++ org/apache/tools/ant/types/selectors/SelectorUtils.java
@@ -548,79 +548,79 @@ public final class SelectorUtils {
     }
 
 
-    /**
-     * Returns dependency information on these two files. If src has been
-     * modified later than target, it returns true. If target doesn't exist,
-     * it likewise returns true. Otherwise, target is newer than src and
-     * is not out of date, thus the method returns false. It also returns
-     * false if the src file doesn't even exist, since how could the
-     * target then be out of date.
-     *
-     * @param src the original file
-     * @param target the file being compared against
-     * @param granularity the amount in seconds of slack we will give in
-     *        determining out of dateness
-     * @return whether the target is out of date
-     */
-    public static boolean isOutOfDate(File src, File target, int granularity) {
-        if (!src.exists()) {
-            return false;
-        }
-        if (!target.exists()) {
-            return true;
-        }
-        if ((src.lastModified() - granularity) > target.lastModified()) {
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Returns dependency information on these two resources. If src has been
-     * modified later than target, it returns true. If target doesn't exist,
-     * it likewise returns true. Otherwise, target is newer than src and
-     * is not out of date, thus the method returns false. It also returns
-     * false if the src file doesn't even exist, since how could the
-     * target then be out of date.
-     *
-     * @param src the original resource
-     * @param target the resource being compared against
-     * @param granularity the amount in seconds of slack we will give in
-     *        determining out of dateness
-     * @return whether the target is out of date
-     */
-    public static boolean isOutOfDate(Resource src, Resource target,
-                                      int granularity) {
-        if (!src.isExists()) {
-            return false;
-        }
-        if (!target.isExists()) {
-            return true;
-        }
-        if ((src.getLastModified() - granularity) > target.getLastModified()) {
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * "Flattens" a string by removing all whitespace (space, tab, linefeed,
-     * carriage return, and formfeed). This uses StringTokenizer and the
-     * default set of tokens as documented in the single arguement constructor.
-     *
-     * @param input a String to remove all whitespace.
-     * @return a String that has had all whitespace removed.
-     */
-    public static String removeWhitespace(String input) {
-        StringBuffer result = new StringBuffer();
-        if (input != null) {
-            StringTokenizer st = new StringTokenizer(input);
-            while (st.hasMoreTokens()) {
-                result.append(st.nextToken());
-            }
-        }
-        return result.toString();
-    }
+//    /**
+//     * Returns dependency information on these two files. If src has been
+//     * modified later than target, it returns true. If target doesn't exist,
+//     * it likewise returns true. Otherwise, target is newer than src and
+//     * is not out of date, thus the method returns false. It also returns
+//     * false if the src file doesn't even exist, since how could the
+//     * target then be out of date.
+//     *
+//     * @param src the original file
+//     * @param target the file being compared against
+//     * @param granularity the amount in seconds of slack we will give in
+//     *        determining out of dateness
+//     * @return whether the target is out of date
+//     */
+//    public static boolean isOutOfDate(File src, File target, int granularity) {
+//        if (!src.exists()) {
+//            return false;
+//        }
+//        if (!target.exists()) {
+//            return true;
+//        }
+//        if ((src.lastModified() - granularity) > target.lastModified()) {
+//            return true;
+//        }
+//        return false;
+//    }
+
+//    /**
+//     * Returns dependency information on these two resources. If src has been
+//     * modified later than target, it returns true. If target doesn't exist,
+//     * it likewise returns true. Otherwise, target is newer than src and
+//     * is not out of date, thus the method returns false. It also returns
+//     * false if the src file doesn't even exist, since how could the
+//     * target then be out of date.
+//     *
+//     * @param src the original resource
+//     * @param target the resource being compared against
+//     * @param granularity the amount in seconds of slack we will give in
+//     *        determining out of dateness
+//     * @return whether the target is out of date
+//     */
+//    public static boolean isOutOfDate(Resource src, Resource target,
+//                                      int granularity) {
+//        if (!src.isExists()) {
+//            return false;
+//        }
+//        if (!target.isExists()) {
+//            return true;
+//        }
+//        if ((src.getLastModified() - granularity) > target.getLastModified()) {
+//            return true;
+//        }
+//        return false;
+//    }
+
+//    /**
+//     * "Flattens" a string by removing all whitespace (space, tab, linefeed,
+//     * carriage return, and formfeed). This uses StringTokenizer and the
+//     * default set of tokens as documented in the single arguement constructor.
+//     *
+//     * @param input a String to remove all whitespace.
+//     * @return a String that has had all whitespace removed.
+//     */
+//    public static String removeWhitespace(String input) {
+//        StringBuffer result = new StringBuffer();
+//        if (input != null) {
+//            StringTokenizer st = new StringTokenizer(input);
+//            while (st.hasMoreTokens()) {
+//                result.append(st.nextToken());
+//            }
+//        }
+//        return result.toString();
+//    }
 
     /**
      * Tests if a string contains stars or question marks
diff --git org/apache/tools/ant/util/FileUtils.java org/apache/tools/ant/util/FileUtils.java
index d2980b0..e426dfe 100644
--- org/apache/tools/ant/util/FileUtils.java
+++ org/apache/tools/ant/util/FileUtils.java
@@ -42,11 +42,11 @@ import java.util.Stack;
 import java.util.StringTokenizer;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
-import org.apache.tools.ant.Project;
-import org.apache.tools.ant.filters.util.ChainReaderHelper;
+//import org.apache.tools.ant.Project;
+//import org.apache.tools.ant.filters.util.ChainReaderHelper;
 import org.apache.tools.ant.taskdefs.condition.Os;
-import org.apache.tools.ant.types.FilterSetCollection;
-import org.apache.tools.ant.launch.Locator;
+//import org.apache.tools.ant.types.FilterSetCollection;
+//import org.apache.tools.ant.launch.Locator;
 
 /**
  * This class also encapsulates methods which allow Files to be
@@ -60,29 +60,29 @@ public class FileUtils {
 
     private static final FileUtils PRIMARY_INSTANCE = new FileUtils();
 
-    //get some non-crypto-grade randomness from various places.
-    private static Random rand = new Random(System.currentTimeMillis()
-            + Runtime.getRuntime().freeMemory());
+//    //get some non-crypto-grade randomness from various places.
+//    private static Random rand = new Random(System.currentTimeMillis()
+//            + Runtime.getRuntime().freeMemory());
 
     private static boolean onNetWare = Os.isFamily("netware");
     private static boolean onDos = Os.isFamily("dos");
 
-    private static final int BUF_SIZE = 8192;
+//    private static final int BUF_SIZE = 8192;
 
     // for toURI
     private static boolean[] isSpecial = new boolean[256];
     private static char[] escapedChar1 = new char[256];
     private static char[] escapedChar2 = new char[256];
 
-    /**
-     * The granularity of timestamps under FAT.
-     */
-    public static final long FAT_FILE_TIMESTAMP_GRANULARITY = 2000;
+//    /**
+//     * The granularity of timestamps under FAT.
+//     */
+//    public static final long FAT_FILE_TIMESTAMP_GRANULARITY = 2000;
 
-    /**
-     * The granularity of timestamps under Unix.
-     */
-    public static final long UNIX_FILE_TIMESTAMP_GRANULARITY = 1000;
+//    /**
+//     * The granularity of timestamps under Unix.
+//     */
+//    public static final long UNIX_FILE_TIMESTAMP_GRANULARITY = 1000;
 
 
     // stolen from FilePathToURI of the Xerces-J team
@@ -107,14 +107,14 @@ public class FileUtils {
         }
     }
 
-    /**
-     * Factory method.
-     *
-     * @return a new instance of FileUtils.
-     */
-    public static FileUtils newFileUtils() {
-        return new FileUtils();
-    }
+//    /**
+//     * Factory method.
+//     *
+//     * @return a new instance of FileUtils.
+//     */
+//    public static FileUtils newFileUtils() {
+//        return new FileUtils();
+//    }
 
     /**
      * Method to retrieve The FileUtils, which is shared by all users of this
@@ -132,532 +132,532 @@ public class FileUtils {
     protected FileUtils() {
     }
 
-    /**
-     * Get the URL for a file taking into account # characters.
-     *
-     * @param file the file whose URL representation is required.
-     * @return The FileURL value.
-     * @throws MalformedURLException if the URL representation cannot be
-     *      formed.
-     */
-    public URL getFileURL(File file) throws MalformedURLException {
-        return new URL(toURI(file.getAbsolutePath()));
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a destination.
-     * No filtering is performed.
-     *
-     * @param sourceFile Name of file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile Name of file to copy to.
-     *                 Must not be <code>null</code>.
-     *
-     * @throws IOException if the copying fails.
-     */
-    public void copyFile(String sourceFile, String destFile)
-        throws IOException {
-        copyFile(new File(sourceFile), new File(destFile), null, false, false);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a destination
-     * specifying if token filtering must be used.
-     *
-     * @param sourceFile Name of file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile Name of file to copy to.
-     *                 Must not be <code>null</code>.
-     * @param filters the collection of filters to apply to this copy.
-     *
-     * @throws IOException if the copying fails.
-     */
-    public void copyFile(String sourceFile, String destFile,
-                         FilterSetCollection filters)
-        throws IOException {
-        copyFile(new File(sourceFile), new File(destFile), filters,
-                 false, false);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a
-     * destination specifying if token filtering must be used and if
-     * source files may overwrite newer destination files.
-     *
-     * @param sourceFile Name of file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile Name of file to copy to.
-     *                 Must not be <code>null</code>.
-     * @param filters the collection of filters to apply to this copy.
-     * @param overwrite Whether or not the destination file should be
-     *                  overwritten if it already exists.
-     *
-     * @throws IOException if the copying fails.
-     */
-    public void copyFile(String sourceFile, String destFile, FilterSetCollection filters,
-                         boolean overwrite) throws IOException {
-        copyFile(new File(sourceFile), new File(destFile), filters,
-                 overwrite, false);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a
-     * destination specifying if token filtering must be used, if
-     * source files may overwrite newer destination files and the
-     * last modified time of <code>destFile</code> file should be made equal
-     * to the last modified time of <code>sourceFile</code>.
-     *
-     * @param sourceFile Name of file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile Name of file to copy to.
-     *                 Must not be <code>null</code>.
-     * @param filters the collection of filters to apply to this copy.
-     * @param overwrite Whether or not the destination file should be
-     *                  overwritten if it already exists.
-     * @param preserveLastModified Whether or not the last modified time of
-     *                             the resulting file should be set to that
-     *                             of the source file.
-     *
-     * @throws IOException if the copying fails.
-     */
-    public void copyFile(String sourceFile, String destFile, FilterSetCollection filters,
-                         boolean overwrite, boolean preserveLastModified)
-        throws IOException {
-        copyFile(new File(sourceFile), new File(destFile), filters,
-                 overwrite, preserveLastModified);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a
-     * destination specifying if token filtering must be used, if
-     * source files may overwrite newer destination files and the
-     * last modified time of <code>destFile</code> file should be made equal
-     * to the last modified time of <code>sourceFile</code>.
-     *
-     * @param sourceFile Name of file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile Name of file to copy to.
-     *                 Must not be <code>null</code>.
-     * @param filters the collection of filters to apply to this copy.
-     * @param overwrite Whether or not the destination file should be
-     *                  overwritten if it already exists.
-     * @param preserveLastModified Whether or not the last modified time of
-     *                             the resulting file should be set to that
-     *                             of the source file.
-     * @param encoding the encoding used to read and write the files.
-     *
-     * @throws IOException if the copying fails.
-     *
-     * @since Ant 1.5
-     */
-    public void copyFile(String sourceFile, String destFile,
-                         FilterSetCollection filters, boolean overwrite,
-                         boolean preserveLastModified, String encoding)
-        throws IOException {
-        copyFile(new File(sourceFile), new File(destFile), filters,
-                 overwrite, preserveLastModified, encoding);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a
-     * destination specifying if token filtering must be used, if
-     * filter chains must be used, if source files may overwrite
-     * newer destination files and the last modified time of
-     * <code>destFile</code> file should be made equal
-     * to the last modified time of <code>sourceFile</code>.
-     *
-     * @param sourceFile Name of file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile Name of file to copy to.
-     *                 Must not be <code>null</code>.
-     * @param filters the collection of filters to apply to this copy.
-     * @param filterChains filterChains to apply during the copy.
-     * @param overwrite Whether or not the destination file should be
-     *                  overwritten if it already exists.
-     * @param preserveLastModified Whether or not the last modified time of
-     *                             the resulting file should be set to that
-     *                             of the source file.
-     * @param encoding the encoding used to read and write the files.
-     * @param project the project instance.
-     *
-     * @throws IOException if the copying fails.
-     *
-     * @since Ant 1.5
-     */
-    public void copyFile(String sourceFile, String destFile,
-                         FilterSetCollection filters, Vector filterChains,
-                         boolean overwrite, boolean preserveLastModified,
-                         String encoding, Project project)
-        throws IOException {
-        copyFile(new File(sourceFile), new File(destFile), filters,
-                 filterChains, overwrite, preserveLastModified,
-                 encoding, project);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a
-     * destination specifying if token filtering must be used, if
-     * filter chains must be used, if source files may overwrite
-     * newer destination files and the last modified time of
-     * <code>destFile</code> file should be made equal
-     * to the last modified time of <code>sourceFile</code>.
-     *
-     * @param sourceFile Name of file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile Name of file to copy to.
-     *                 Must not be <code>null</code>.
-     * @param filters the collection of filters to apply to this copy.
-     * @param filterChains filterChains to apply during the copy.
-     * @param overwrite Whether or not the destination file should be
-     *                  overwritten if it already exists.
-     * @param preserveLastModified Whether or not the last modified time of
-     *                             the resulting file should be set to that
-     *                             of the source file.
-     * @param inputEncoding the encoding used to read the files.
-     * @param outputEncoding the encoding used to write the files.
-     * @param project the project instance.
-     *
-     * @throws IOException if the copying fails.
-     *
-     * @since Ant 1.6
-     */
-    public void copyFile(String sourceFile, String destFile,
-                         FilterSetCollection filters, Vector filterChains,
-                         boolean overwrite, boolean preserveLastModified,
-                         String inputEncoding, String outputEncoding,
-                         Project project)
-        throws IOException {
-        copyFile(new File(sourceFile), new File(destFile), filters,
-                 filterChains, overwrite, preserveLastModified,
-                 inputEncoding, outputEncoding, project);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a destination.
-     * No filtering is performed.
-     *
-     * @param sourceFile the file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile the file to copy to.
-     *                 Must not be <code>null</code>.
-     *
-     * @throws IOException if the copying fails.
-     */
-    public void copyFile(File sourceFile, File destFile) throws IOException {
-        copyFile(sourceFile, destFile, null, false, false);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a destination
-     * specifying if token filtering must be used.
-     *
-     * @param sourceFile the file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile the file to copy to.
-     *                 Must not be <code>null</code>.
-     * @param filters the collection of filters to apply to this copy.
-     *
-     * @throws IOException if the copying fails.
-     */
-    public void copyFile(File sourceFile, File destFile, FilterSetCollection filters)
-        throws IOException {
-        copyFile(sourceFile, destFile, filters, false, false);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a
-     * destination specifying if token filtering must be used and if
-     * source files may overwrite newer destination files.
-     *
-     * @param sourceFile the file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile the file to copy to.
-     *                 Must not be <code>null</code>.
-     * @param filters the collection of filters to apply to this copy.
-     * @param overwrite Whether or not the destination file should be
-     *                  overwritten if it already exists.
-     *
-     * @throws IOException if the copying fails.
-     */
-    public void copyFile(File sourceFile, File destFile, FilterSetCollection filters,
-                         boolean overwrite) throws IOException {
-        copyFile(sourceFile, destFile, filters, overwrite, false);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a
-     * destination specifying if token filtering must be used, if
-     * source files may overwrite newer destination files and the
-     * last modified time of <code>destFile</code> file should be made equal
-     * to the last modified time of <code>sourceFile</code>.
-     *
-     * @param sourceFile the file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile the file to copy to.
-     *                 Must not be <code>null</code>.
-     * @param filters the collection of filters to apply to this copy.
-     * @param overwrite Whether or not the destination file should be
-     *                  overwritten if it already exists.
-     * @param preserveLastModified Whether or not the last modified time of
-     *                             the resulting file should be set to that
-     *                             of the source file.
-     *
-     * @throws IOException if the copying fails.
-     */
-    public void copyFile(File sourceFile, File destFile, FilterSetCollection filters,
-                         boolean overwrite, boolean preserveLastModified)
-        throws IOException {
-        copyFile(sourceFile, destFile, filters, overwrite,
-                 preserveLastModified, null);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a
-     * destination specifying if token filtering must be used, if
-     * source files may overwrite newer destination files, the last
-     * modified time of <code>destFile</code> file should be made
-     * equal to the last modified time of <code>sourceFile</code> and
-     * which character encoding to assume.
-     *
-     * @param sourceFile the file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile the file to copy to.
-     *                 Must not be <code>null</code>.
-     * @param filters the collection of filters to apply to this copy.
-     * @param overwrite Whether or not the destination file should be
-     *                  overwritten if it already exists.
-     * @param preserveLastModified Whether or not the last modified time of
-     *                             the resulting file should be set to that
-     *                             of the source file.
-     * @param encoding the encoding used to read and write the files.
-     *
-     * @throws IOException if the copying fails.
-     *
-     * @since Ant 1.5
-     */
-    public void copyFile(File sourceFile, File destFile,
-                         FilterSetCollection filters, boolean overwrite,
-                         boolean preserveLastModified, String encoding)
-        throws IOException {
-        copyFile(sourceFile, destFile, filters, null, overwrite,
-                 preserveLastModified, encoding, null);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a
-     * destination specifying if token filtering must be used, if
-     * filter chains must be used, if source files may overwrite
-     * newer destination files and the last modified time of
-     * <code>destFile</code> file should be made equal
-     * to the last modified time of <code>sourceFile</code>.
-     *
-     * @param sourceFile the file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile the file to copy to.
-     *                 Must not be <code>null</code>.
-     * @param filters the collection of filters to apply to this copy.
-     * @param filterChains filterChains to apply during the copy.
-     * @param overwrite Whether or not the destination file should be
-     *                  overwritten if it already exists.
-     * @param preserveLastModified Whether or not the last modified time of
-     *                             the resulting file should be set to that
-     *                             of the source file.
-     * @param encoding the encoding used to read and write the files.
-     * @param project the project instance.
-     *
-     * @throws IOException if the copying fails.
-     *
-     * @since Ant 1.5
-     */
-    public void copyFile(File sourceFile, File destFile,
-                         FilterSetCollection filters, Vector filterChains,
-                         boolean overwrite, boolean preserveLastModified,
-                         String encoding, Project project)
-        throws IOException {
-        copyFile(sourceFile, destFile, filters, filterChains,
-                 overwrite, preserveLastModified, encoding, encoding, project);
-    }
-
-    /**
-     * Convenience method to copy a file from a source to a
-     * destination specifying if token filtering must be used, if
-     * filter chains must be used, if source files may overwrite
-     * newer destination files and the last modified time of
-     * <code>destFile</code> file should be made equal
-     * to the last modified time of <code>sourceFile</code>.
-     *
-     * @param sourceFile the file to copy from.
-     *                   Must not be <code>null</code>.
-     * @param destFile the file to copy to.
-     *                 Must not be <code>null</code>.
-     * @param filters the collection of filters to apply to this copy.
-     * @param filterChains filterChains to apply during the copy.
-     * @param overwrite Whether or not the destination file should be
-     *                  overwritten if it already exists.
-     * @param preserveLastModified Whether or not the last modified time of
-     *                             the resulting file should be set to that
-     *                             of the source file.
-     * @param inputEncoding the encoding used to read the files.
-     * @param outputEncoding the encoding used to write the files.
-     * @param project the project instance.
-     *
-     *
-     * @throws IOException if the copying fails.
-     *
-     * @since Ant 1.6
-     */
-    public void copyFile(File sourceFile, File destFile,
-                         FilterSetCollection filters, Vector filterChains,
-                         boolean overwrite, boolean preserveLastModified,
-                         String inputEncoding, String outputEncoding,
-                         Project project)
-        throws IOException {
-
-        if (overwrite || !destFile.exists()
-            || destFile.lastModified() < sourceFile.lastModified()) {
-
-            if (destFile.exists() && destFile.isFile()) {
-                destFile.delete();
-            }
-            // ensure that parent dir of dest file exists!
-            // not using getParentFile method to stay 1.1 compat
-            File parent = destFile.getParentFile();
-            if (parent != null && !parent.exists()) {
-                parent.mkdirs();
-            }
-            final boolean filterSetsAvailable = (filters != null
-                                                 && filters.hasFilters());
-            final boolean filterChainsAvailable = (filterChains != null
-                                                   && filterChains.size() > 0);
-            if (filterSetsAvailable) {
-                BufferedReader in = null;
-                BufferedWriter out = null;
-                try {
-                    if (inputEncoding == null) {
-                        in = new BufferedReader(new FileReader(sourceFile));
-                    } else {
-                        InputStreamReader isr
-                            = new InputStreamReader(new FileInputStream(sourceFile),
-                                                    inputEncoding);
-                        in = new BufferedReader(isr);
-                    }
-                    if (outputEncoding == null) {
-                        out = new BufferedWriter(new FileWriter(destFile));
-                    } else {
-                        OutputStreamWriter osw
-                            = new OutputStreamWriter(new FileOutputStream(destFile),
-                                                     outputEncoding);
-                        out = new BufferedWriter(osw);
-                    }
-                    if (filterChainsAvailable) {
-                        ChainReaderHelper crh = new ChainReaderHelper();
-                        crh.setBufferSize(BUF_SIZE);
-                        crh.setPrimaryReader(in);
-                        crh.setFilterChains(filterChains);
-                        crh.setProject(project);
-                        Reader rdr = crh.getAssembledReader();
-                        in = new BufferedReader(rdr);
-                    }
-                    LineTokenizer lineTokenizer = new LineTokenizer();
-                    lineTokenizer.setIncludeDelims(true);
-                    String newline = null;
-                    String line = lineTokenizer.getToken(in);
-                    while (line != null) {
-                        if (line.length() == 0) {
-                            // this should not happen, because the lines are
-                            // returned with the end of line delimiter
-                            out.newLine();
-                        } else {
-                            newline = filters.replaceTokens(line);
-                            out.write(newline);
-                        }
-                        line = lineTokenizer.getToken(in);
-                    }
-                } finally {
-                    close(out);
-                    close(in);
-                }
-            } else if (filterChainsAvailable
-                       || (inputEncoding != null
-                           && !inputEncoding.equals(outputEncoding))
-                       || (inputEncoding == null && outputEncoding != null)) {
-                BufferedReader in = null;
-                BufferedWriter out = null;
-                 try {
-                     if (inputEncoding == null) {
-                         in = new BufferedReader(new FileReader(sourceFile));
-                     } else {
-                         in =
-                             new BufferedReader(
-                                 new InputStreamReader(
-                                     new FileInputStream(sourceFile),
-                                     inputEncoding));
-                     }
-                     if (outputEncoding == null) {
-                         out = new BufferedWriter(new FileWriter(destFile));
-                     } else {
-                         out =
-                             new BufferedWriter(
-                                 new OutputStreamWriter(
-                                     new FileOutputStream(destFile),
-                                     outputEncoding));
-                     }
-                     if (filterChainsAvailable) {
-                         ChainReaderHelper crh = new ChainReaderHelper();
-                         crh.setBufferSize(BUF_SIZE);
-                         crh.setPrimaryReader(in);
-                         crh.setFilterChains(filterChains);
-                         crh.setProject(project);
-                         Reader rdr = crh.getAssembledReader();
-                         in = new BufferedReader(rdr);
-                     }
-                     char[] buffer = new char[BUF_SIZE];
-                     while (true) {
-                         int nRead = in.read(buffer, 0, buffer.length);
-                         if (nRead == -1) {
-                             break;
-                         }
-                         out.write(buffer, 0, nRead);
-                      }
-                 } finally {
-                     close(out);
-                     close(in);
-                 }
-            } else {
-                FileInputStream in = null;
-                FileOutputStream out = null;
-                try {
-                    in = new FileInputStream(sourceFile);
-                    out = new FileOutputStream(destFile);
-
-                    byte[] buffer = new byte[BUF_SIZE];
-                    int count = 0;
-                    do {
-                        out.write(buffer, 0, count);
-                        count = in.read(buffer, 0, buffer.length);
-                    } while (count != -1);
-                } finally {
-                    close(out);
-                    close(in);
-                }
-            }
-            if (preserveLastModified) {
-                setFileLastModified(destFile, sourceFile.lastModified());
-            }
-        }
-    }
-
-    /**
-     * Calls File.setLastModified(long time). Originally written to
-     * to dynamically bind to that call on Java1.2+.
-     *
-     * @param file the file whose modified time is to be set
-     * @param time the time to which the last modified time is to be set.
-     *             if this is -1, the current time is used.
-     */
-    public void setFileLastModified(File file, long time) {
-        file.setLastModified((time < 0) ? System.currentTimeMillis() : time);
-    }
+//    /**
+//     * Get the URL for a file taking into account # characters.
+//     *
+//     * @param file the file whose URL representation is required.
+//     * @return The FileURL value.
+//     * @throws MalformedURLException if the URL representation cannot be
+//     *      formed.
+//     */
+//    public URL getFileURL(File file) throws MalformedURLException {
+//        return new URL(toURI(file.getAbsolutePath()));
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a destination.
+//     * No filtering is performed.
+//     *
+//     * @param sourceFile Name of file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile Name of file to copy to.
+//     *                 Must not be <code>null</code>.
+//     *
+//     * @throws IOException if the copying fails.
+//     */
+//    public void copyFile(String sourceFile, String destFile)
+//        throws IOException {
+//        copyFile(new File(sourceFile), new File(destFile), null, false, false);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a destination
+//     * specifying if token filtering must be used.
+//     *
+//     * @param sourceFile Name of file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile Name of file to copy to.
+//     *                 Must not be <code>null</code>.
+//     * @param filters the collection of filters to apply to this copy.
+//     *
+//     * @throws IOException if the copying fails.
+//     */
+//    public void copyFile(String sourceFile, String destFile,
+//                         FilterSetCollection filters)
+//        throws IOException {
+//        copyFile(new File(sourceFile), new File(destFile), filters,
+//                 false, false);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a
+//     * destination specifying if token filtering must be used and if
+//     * source files may overwrite newer destination files.
+//     *
+//     * @param sourceFile Name of file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile Name of file to copy to.
+//     *                 Must not be <code>null</code>.
+//     * @param filters the collection of filters to apply to this copy.
+//     * @param overwrite Whether or not the destination file should be
+//     *                  overwritten if it already exists.
+//     *
+//     * @throws IOException if the copying fails.
+//     */
+//    public void copyFile(String sourceFile, String destFile, FilterSetCollection filters,
+//                         boolean overwrite) throws IOException {
+//        copyFile(new File(sourceFile), new File(destFile), filters,
+//                 overwrite, false);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a
+//     * destination specifying if token filtering must be used, if
+//     * source files may overwrite newer destination files and the
+//     * last modified time of <code>destFile</code> file should be made equal
+//     * to the last modified time of <code>sourceFile</code>.
+//     *
+//     * @param sourceFile Name of file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile Name of file to copy to.
+//     *                 Must not be <code>null</code>.
+//     * @param filters the collection of filters to apply to this copy.
+//     * @param overwrite Whether or not the destination file should be
+//     *                  overwritten if it already exists.
+//     * @param preserveLastModified Whether or not the last modified time of
+//     *                             the resulting file should be set to that
+//     *                             of the source file.
+//     *
+//     * @throws IOException if the copying fails.
+//     */
+//    public void copyFile(String sourceFile, String destFile, FilterSetCollection filters,
+//                         boolean overwrite, boolean preserveLastModified)
+//        throws IOException {
+//        copyFile(new File(sourceFile), new File(destFile), filters,
+//                 overwrite, preserveLastModified);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a
+//     * destination specifying if token filtering must be used, if
+//     * source files may overwrite newer destination files and the
+//     * last modified time of <code>destFile</code> file should be made equal
+//     * to the last modified time of <code>sourceFile</code>.
+//     *
+//     * @param sourceFile Name of file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile Name of file to copy to.
+//     *                 Must not be <code>null</code>.
+//     * @param filters the collection of filters to apply to this copy.
+//     * @param overwrite Whether or not the destination file should be
+//     *                  overwritten if it already exists.
+//     * @param preserveLastModified Whether or not the last modified time of
+//     *                             the resulting file should be set to that
+//     *                             of the source file.
+//     * @param encoding the encoding used to read and write the files.
+//     *
+//     * @throws IOException if the copying fails.
+//     *
+//     * @since Ant 1.5
+//     */
+//    public void copyFile(String sourceFile, String destFile,
+//                         FilterSetCollection filters, boolean overwrite,
+//                         boolean preserveLastModified, String encoding)
+//        throws IOException {
+//        copyFile(new File(sourceFile), new File(destFile), filters,
+//                 overwrite, preserveLastModified, encoding);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a
+//     * destination specifying if token filtering must be used, if
+//     * filter chains must be used, if source files may overwrite
+//     * newer destination files and the last modified time of
+//     * <code>destFile</code> file should be made equal
+//     * to the last modified time of <code>sourceFile</code>.
+//     *
+//     * @param sourceFile Name of file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile Name of file to copy to.
+//     *                 Must not be <code>null</code>.
+//     * @param filters the collection of filters to apply to this copy.
+//     * @param filterChains filterChains to apply during the copy.
+//     * @param overwrite Whether or not the destination file should be
+//     *                  overwritten if it already exists.
+//     * @param preserveLastModified Whether or not the last modified time of
+//     *                             the resulting file should be set to that
+//     *                             of the source file.
+//     * @param encoding the encoding used to read and write the files.
+//     * @param project the project instance.
+//     *
+//     * @throws IOException if the copying fails.
+//     *
+//     * @since Ant 1.5
+//     */
+//    public void copyFile(String sourceFile, String destFile,
+//                         FilterSetCollection filters, Vector filterChains,
+//                         boolean overwrite, boolean preserveLastModified,
+//                         String encoding, Project project)
+//        throws IOException {
+//        copyFile(new File(sourceFile), new File(destFile), filters,
+//                 filterChains, overwrite, preserveLastModified,
+//                 encoding, project);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a
+//     * destination specifying if token filtering must be used, if
+//     * filter chains must be used, if source files may overwrite
+//     * newer destination files and the last modified time of
+//     * <code>destFile</code> file should be made equal
+//     * to the last modified time of <code>sourceFile</code>.
+//     *
+//     * @param sourceFile Name of file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile Name of file to copy to.
+//     *                 Must not be <code>null</code>.
+//     * @param filters the collection of filters to apply to this copy.
+//     * @param filterChains filterChains to apply during the copy.
+//     * @param overwrite Whether or not the destination file should be
+//     *                  overwritten if it already exists.
+//     * @param preserveLastModified Whether or not the last modified time of
+//     *                             the resulting file should be set to that
+//     *                             of the source file.
+//     * @param inputEncoding the encoding used to read the files.
+//     * @param outputEncoding the encoding used to write the files.
+//     * @param project the project instance.
+//     *
+//     * @throws IOException if the copying fails.
+//     *
+//     * @since Ant 1.6
+//     */
+//    public void copyFile(String sourceFile, String destFile,
+//                         FilterSetCollection filters, Vector filterChains,
+//                         boolean overwrite, boolean preserveLastModified,
+//                         String inputEncoding, String outputEncoding,
+//                         Project project)
+//        throws IOException {
+//        copyFile(new File(sourceFile), new File(destFile), filters,
+//                 filterChains, overwrite, preserveLastModified,
+//                 inputEncoding, outputEncoding, project);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a destination.
+//     * No filtering is performed.
+//     *
+//     * @param sourceFile the file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile the file to copy to.
+//     *                 Must not be <code>null</code>.
+//     *
+//     * @throws IOException if the copying fails.
+//     */
+//    public void copyFile(File sourceFile, File destFile) throws IOException {
+//        copyFile(sourceFile, destFile, null, false, false);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a destination
+//     * specifying if token filtering must be used.
+//     *
+//     * @param sourceFile the file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile the file to copy to.
+//     *                 Must not be <code>null</code>.
+//     * @param filters the collection of filters to apply to this copy.
+//     *
+//     * @throws IOException if the copying fails.
+//     */
+//    public void copyFile(File sourceFile, File destFile, FilterSetCollection filters)
+//        throws IOException {
+//        copyFile(sourceFile, destFile, filters, false, false);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a
+//     * destination specifying if token filtering must be used and if
+//     * source files may overwrite newer destination files.
+//     *
+//     * @param sourceFile the file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile the file to copy to.
+//     *                 Must not be <code>null</code>.
+//     * @param filters the collection of filters to apply to this copy.
+//     * @param overwrite Whether or not the destination file should be
+//     *                  overwritten if it already exists.
+//     *
+//     * @throws IOException if the copying fails.
+//     */
+//    public void copyFile(File sourceFile, File destFile, FilterSetCollection filters,
+//                         boolean overwrite) throws IOException {
+//        copyFile(sourceFile, destFile, filters, overwrite, false);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a
+//     * destination specifying if token filtering must be used, if
+//     * source files may overwrite newer destination files and the
+//     * last modified time of <code>destFile</code> file should be made equal
+//     * to the last modified time of <code>sourceFile</code>.
+//     *
+//     * @param sourceFile the file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile the file to copy to.
+//     *                 Must not be <code>null</code>.
+//     * @param filters the collection of filters to apply to this copy.
+//     * @param overwrite Whether or not the destination file should be
+//     *                  overwritten if it already exists.
+//     * @param preserveLastModified Whether or not the last modified time of
+//     *                             the resulting file should be set to that
+//     *                             of the source file.
+//     *
+//     * @throws IOException if the copying fails.
+//     */
+//    public void copyFile(File sourceFile, File destFile, FilterSetCollection filters,
+//                         boolean overwrite, boolean preserveLastModified)
+//        throws IOException {
+//        copyFile(sourceFile, destFile, filters, overwrite,
+//                 preserveLastModified, null);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a
+//     * destination specifying if token filtering must be used, if
+//     * source files may overwrite newer destination files, the last
+//     * modified time of <code>destFile</code> file should be made
+//     * equal to the last modified time of <code>sourceFile</code> and
+//     * which character encoding to assume.
+//     *
+//     * @param sourceFile the file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile the file to copy to.
+//     *                 Must not be <code>null</code>.
+//     * @param filters the collection of filters to apply to this copy.
+//     * @param overwrite Whether or not the destination file should be
+//     *                  overwritten if it already exists.
+//     * @param preserveLastModified Whether or not the last modified time of
+//     *                             the resulting file should be set to that
+//     *                             of the source file.
+//     * @param encoding the encoding used to read and write the files.
+//     *
+//     * @throws IOException if the copying fails.
+//     *
+//     * @since Ant 1.5
+//     */
+//    public void copyFile(File sourceFile, File destFile,
+//                         FilterSetCollection filters, boolean overwrite,
+//                         boolean preserveLastModified, String encoding)
+//        throws IOException {
+//        copyFile(sourceFile, destFile, filters, null, overwrite,
+//                 preserveLastModified, encoding, null);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a
+//     * destination specifying if token filtering must be used, if
+//     * filter chains must be used, if source files may overwrite
+//     * newer destination files and the last modified time of
+//     * <code>destFile</code> file should be made equal
+//     * to the last modified time of <code>sourceFile</code>.
+//     *
+//     * @param sourceFile the file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile the file to copy to.
+//     *                 Must not be <code>null</code>.
+//     * @param filters the collection of filters to apply to this copy.
+//     * @param filterChains filterChains to apply during the copy.
+//     * @param overwrite Whether or not the destination file should be
+//     *                  overwritten if it already exists.
+//     * @param preserveLastModified Whether or not the last modified time of
+//     *                             the resulting file should be set to that
+//     *                             of the source file.
+//     * @param encoding the encoding used to read and write the files.
+//     * @param project the project instance.
+//     *
+//     * @throws IOException if the copying fails.
+//     *
+//     * @since Ant 1.5
+//     */
+//    public void copyFile(File sourceFile, File destFile,
+//                         FilterSetCollection filters, Vector filterChains,
+//                         boolean overwrite, boolean preserveLastModified,
+//                         String encoding, Project project)
+//        throws IOException {
+//        copyFile(sourceFile, destFile, filters, filterChains,
+//                 overwrite, preserveLastModified, encoding, encoding, project);
+//    }
+//
+//    /**
+//     * Convenience method to copy a file from a source to a
+//     * destination specifying if token filtering must be used, if
+//     * filter chains must be used, if source files may overwrite
+//     * newer destination files and the last modified time of
+//     * <code>destFile</code> file should be made equal
+//     * to the last modified time of <code>sourceFile</code>.
+//     *
+//     * @param sourceFile the file to copy from.
+//     *                   Must not be <code>null</code>.
+//     * @param destFile the file to copy to.
+//     *                 Must not be <code>null</code>.
+//     * @param filters the collection of filters to apply to this copy.
+//     * @param filterChains filterChains to apply during the copy.
+//     * @param overwrite Whether or not the destination file should be
+//     *                  overwritten if it already exists.
+//     * @param preserveLastModified Whether or not the last modified time of
+//     *                             the resulting file should be set to that
+//     *                             of the source file.
+//     * @param inputEncoding the encoding used to read the files.
+//     * @param outputEncoding the encoding used to write the files.
+//     * @param project the project instance.
+//     *
+//     *
+//     * @throws IOException if the copying fails.
+//     *
+//     * @since Ant 1.6
+//     */
+//    public void copyFile(File sourceFile, File destFile,
+//                         FilterSetCollection filters, Vector filterChains,
+//                         boolean overwrite, boolean preserveLastModified,
+//                         String inputEncoding, String outputEncoding,
+//                         Project project)
+//        throws IOException {
+//
+//        if (overwrite || !destFile.exists()
+//            || destFile.lastModified() < sourceFile.lastModified()) {
+//
+//            if (destFile.exists() && destFile.isFile()) {
+//                destFile.delete();
+//            }
+//            // ensure that parent dir of dest file exists!
+//            // not using getParentFile method to stay 1.1 compat
+//            File parent = destFile.getParentFile();
+//            if (parent != null && !parent.exists()) {
+//                parent.mkdirs();
+//            }
+//            final boolean filterSetsAvailable = (filters != null
+//                                                 && filters.hasFilters());
+//            final boolean filterChainsAvailable = (filterChains != null
+//                                                   && filterChains.size() > 0);
+//            if (filterSetsAvailable) {
+//                BufferedReader in = null;
+//                BufferedWriter out = null;
+//                try {
+//                    if (inputEncoding == null) {
+//                        in = new BufferedReader(new FileReader(sourceFile));
+//                    } else {
+//                        InputStreamReader isr
+//                            = new InputStreamReader(new FileInputStream(sourceFile),
+//                                                    inputEncoding);
+//                        in = new BufferedReader(isr);
+//                    }
+//                    if (outputEncoding == null) {
+//                        out = new BufferedWriter(new FileWriter(destFile));
+//                    } else {
+//                        OutputStreamWriter osw
+//                            = new OutputStreamWriter(new FileOutputStream(destFile),
+//                                                     outputEncoding);
+//                        out = new BufferedWriter(osw);
+//                    }
+//                    if (filterChainsAvailable) {
+//                        ChainReaderHelper crh = new ChainReaderHelper();
+//                        crh.setBufferSize(BUF_SIZE);
+//                        crh.setPrimaryReader(in);
+//                        crh.setFilterChains(filterChains);
+//                        crh.setProject(project);
+//                        Reader rdr = crh.getAssembledReader();
+//                        in = new BufferedReader(rdr);
+//                    }
+//                    LineTokenizer lineTokenizer = new LineTokenizer();
+//                    lineTokenizer.setIncludeDelims(true);
+//                    String newline = null;
+//                    String line = lineTokenizer.getToken(in);
+//                    while (line != null) {
+//                        if (line.length() == 0) {
+//                            // this should not happen, because the lines are
+//                            // returned with the end of line delimiter
+//                            out.newLine();
+//                        } else {
+//                            newline = filters.replaceTokens(line);
+//                            out.write(newline);
+//                        }
+//                        line = lineTokenizer.getToken(in);
+//                    }
+//                } finally {
+//                    close(out);
+//                    close(in);
+//                }
+//            } else if (filterChainsAvailable
+//                       || (inputEncoding != null
+//                           && !inputEncoding.equals(outputEncoding))
+//                       || (inputEncoding == null && outputEncoding != null)) {
+//                BufferedReader in = null;
+//                BufferedWriter out = null;
+//                 try {
+//                     if (inputEncoding == null) {
+//                         in = new BufferedReader(new FileReader(sourceFile));
+//                     } else {
+//                         in =
+//                             new BufferedReader(
+//                                 new InputStreamReader(
+//                                     new FileInputStream(sourceFile),
+//                                     inputEncoding));
+//                     }
+//                     if (outputEncoding == null) {
+//                         out = new BufferedWriter(new FileWriter(destFile));
+//                     } else {
+//                         out =
+//                             new BufferedWriter(
+//                                 new OutputStreamWriter(
+//                                     new FileOutputStream(destFile),
+//                                     outputEncoding));
+//                     }
+//                     if (filterChainsAvailable) {
+//                         ChainReaderHelper crh = new ChainReaderHelper();
+//                         crh.setBufferSize(BUF_SIZE);
+//                         crh.setPrimaryReader(in);
+//                         crh.setFilterChains(filterChains);
+//                         crh.setProject(project);
+//                         Reader rdr = crh.getAssembledReader();
+//                         in = new BufferedReader(rdr);
+//                     }
+//                     char[] buffer = new char[BUF_SIZE];
+//                     while (true) {
+//                         int nRead = in.read(buffer, 0, buffer.length);
+//                         if (nRead == -1) {
+//                             break;
+//                         }
+//                         out.write(buffer, 0, nRead);
+//                      }
+//                 } finally {
+//                     close(out);
+//                     close(in);
+//                 }
+//            } else {
+//                FileInputStream in = null;
+//                FileOutputStream out = null;
+//                try {
+//                    in = new FileInputStream(sourceFile);
+//                    out = new FileOutputStream(destFile);
+//
+//                    byte[] buffer = new byte[BUF_SIZE];
+//                    int count = 0;
+//                    do {
+//                        out.write(buffer, 0, count);
+//                        count = in.read(buffer, 0, buffer.length);
+//                    } while (count != -1);
+//                } finally {
+//                    close(out);
+//                    close(in);
+//                }
+//            }
+//            if (preserveLastModified) {
+//                setFileLastModified(destFile, sourceFile.lastModified());
+//            }
+//        }
+//    }
+//
+//    /**
+//     * Calls File.setLastModified(long time). Originally written to
+//     * to dynamically bind to that call on Java1.2+.
+//     *
+//     * @param file the file whose modified time is to be set
+//     * @param time the time to which the last modified time is to be set.
+//     *             if this is -1, the current time is used.
+//     */
+//    public void setFileLastModified(File file, long time) {
+//        file.setLastModified((time < 0) ? System.currentTimeMillis() : time);
+//    }
 
     /**
      * Interpret the filename as a file relative to the given file
@@ -838,313 +838,313 @@ public class FileUtils {
         return new File(path);
     }
 
-    /**
-     * Returns a VMS String representation of a <code>File</code> object.
-     * This is useful since the JVM by default internally converts VMS paths
-     * to Unix style.
-     * The returned String is always an absolute path.
-     *
-     * @param f The <code>File</code> to get the VMS path for.
-     * @return The absolute VMS path to <code>f</code>.
-     */
-    public String toVMSPath(File f) {
-        // format: "DEVICE:[DIR.SUBDIR]FILE"
-        String osPath;
-        String path = normalize(f.getAbsolutePath()).getPath();
-        String name = f.getName();
-        boolean isAbsolute = path.charAt(0) == File.separatorChar;
-        // treat directories specified using .DIR syntax as files
-        boolean isDirectory = f.isDirectory()
-            && !name.regionMatches(true, name.length() - 4, ".DIR", 0, 4);
-
-        String device = null;
-        StringBuffer directory = null;
-        String file = null;
-
-        int index = 0;
-
-        if (isAbsolute) {
-            index = path.indexOf(File.separatorChar, 1);
-            if (index == -1) {
-                return path.substring(1) + ":[000000]";
-            } else {
-                device = path.substring(1, index++);
-            }
-        }
-        if (isDirectory) {
-            directory = new StringBuffer(path.substring(index).
-                                         replace(File.separatorChar, '.'));
-        } else {
-            int dirEnd =
-                path.lastIndexOf(File.separatorChar, path.length());
-            if (dirEnd == -1 || dirEnd < index) {
-                file = path.substring(index);
-            } else {
-                directory = new StringBuffer(path.substring(index, dirEnd).
-                                             replace(File.separatorChar, '.'));
-                index = dirEnd + 1;
-                if (path.length() > index) {
-                    file = path.substring(index);
-                }
-            }
-        }
-        if (!isAbsolute && directory != null) {
-            directory.insert(0, '.');
-        }
-        osPath = ((device != null) ? device + ":" : "")
-            + ((directory != null) ? "[" + directory + "]" : "")
-            + ((file != null) ? file : "");
-        return osPath;
-    }
-
-    /**
-     * Create a temporary file in a given directory.
-     *
-     * <p>The file denoted by the returned abstract pathname did not
-     * exist before this method was invoked, any subsequent invocation
-     * of this method will yield a different file name.</p>
-     * <p>
-     * The filename is prefixNNNNNsuffix where NNNN is a random number.
-     * </p>
-     * <p>This method is different from File.createTempFile() of JDK 1.2
-     * as it doesn't create the file itself.  It uses the location pointed
-     * to by java.io.tmpdir when the parentDir attribute is null.</p>
-     *
-     * @param prefix prefix before the random number.
-     * @param suffix file extension; include the '.'.
-     * @param parentDir Directory to create the temporary file in;
-     * java.io.tmpdir used if not specified.
-     *
-     * @return a File reference to the new temporary file.
-     * @since Ant 1.5
-     */
-    public File createTempFile(String prefix, String suffix, File parentDir) {
-        File result = null;
-        String parent = (parentDir == null)
-            ? System.getProperty("java.io.tmpdir")
-            : parentDir.getPath();
-
-        DecimalFormat fmt = new DecimalFormat("#####");
-        synchronized (rand) {
-            do {
-                result = new File(parent,
-                                  prefix + fmt.format(Math.abs(rand.nextInt()))
-                                  + suffix);
-            } while (result.exists());
-        }
-        return result;
-    }
-
-    /**
-     * Compares the contents of two files.
-     *
-     * @param f1 the file whose content is to be compared.
-     * @param f2 the other file whose content is to be compared.
-     *
-     * @return true if the content of the files is the same.
-     *
-     * @throws IOException if the files cannot be read.
-     */
-    public boolean contentEquals(File f1, File f2) throws IOException {
-        return contentEquals(f1, f2, false);
-    }
-
-    /**
-     * Compares the contents of two files.
-     *
-     * @param f1 the file whose content is to be compared.
-     * @param f2 the other file whose content is to be compared.
-     * @param textfile true if the file is to be treated as a text file and
-     *        differences in kind of line break are to be ignored.
-     *
-     * @return true if the content of the files is the same.
-     *
-     * @throws IOException if the files cannot be read.
-     * @since Ant 1.6.3
-     */
-    public boolean contentEquals(File f1, File f2, boolean textfile) throws IOException {
-        if (f1.exists() != f2.exists()) {
-            return false;
-        }
-        if (!f1.exists()) {
-            // two not existing files are equal
-            return true;
-        }
-        // should the following two be switched?  If f1 and f2 refer to the same file,
-        // isn't their content equal regardless of whether that file is a directory?
-        if (f1.isDirectory() || f2.isDirectory()) {
-            // don't want to compare directory contents for now
-            return false;
-        }
-        if (fileNameEquals(f1, f2)) {
-            // same filename => true
-            return true;
-        }
-        return textfile ? textEquals(f1, f2) : binaryEquals(f1, f2);
-    }
-
-    /**
-     * Binary compares the contents of two files.
-     * <p>
-     * simple but sub-optimal comparision algorithm. written for working
-     * rather than fast. Better would be a block read into buffers followed
-     * by long comparisions apart from the final 1-7 bytes.
-     * </p>
-     *
-     * @param f1 the file whose content is to be compared.
-     * @param f2 the other file whose content is to be compared.
-     * @return true if the content of the files is the same.
-     * @throws IOException if the files cannot be read.
-     */
-    private boolean binaryEquals(File f1, File f2) throws IOException {
-        if (f1.length() != f2.length()) {
-            // different size =>false
-            return false;
-        }
-
-        InputStream in1 = null;
-        InputStream in2 = null;
-        try {
-            in1 = new BufferedInputStream(new FileInputStream(f1));
-            in2 = new BufferedInputStream(new FileInputStream(f2));
-
-            int expectedByte = in1.read();
-            while (expectedByte != -1) {
-                if (expectedByte != in2.read()) {
-                    return false;
-                }
-                expectedByte = in1.read();
-            }
-            if (in2.read() != -1) {
-                return false;
-            }
-            return true;
-        } finally {
-            close(in1);
-            close(in2);
-        }
-    }
-
-    /**
-     * Text compares the contents of two files.
-     *
-     * Ignores different kinds of line endings.
-     *
-     * @param f1 the file whose content is to be compared.
-     * @param f2 the other file whose content is to be compared.
-     * @return true if the content of the files is the same.
-     * @throws IOException if the files cannot be read.
-     */
-    private boolean textEquals(File f1, File f2) throws IOException {
-        BufferedReader in1 = null;
-        BufferedReader in2 = null;
-        try {
-            in1 = new BufferedReader(new FileReader(f1));
-            in2 = new BufferedReader(new FileReader(f2));
-
-            String expected = in1.readLine();
-            while (expected != null) {
-                if (!expected.equals(in2.readLine())) {
-                    return false;
-                }
-                expected = in1.readLine();
-            }
-            if (in2.readLine() != null) {
-                return false;
-            }
-            return true;
-        } finally {
-            close(in1);
-            close(in2);
-        }
-    }
-
-    /**
-     * This was originally an emulation of {@link File#getParentFile} for JDK 1.1,
-     * but it is now implemented using that method (Ant 1.6.3 onwards).
-     * @param f the file whose parent is required.
-     * @return the given file's parent, or null if the file does not have a
-     *         parent.
-     * @since 1.10
-     */
-    public File getParentFile(File f) {
-        return (f == null) ? null : f.getParentFile();
-    }
-
-    /**
-     * Read from reader till EOF.
-     * @param rdr the reader from which to read.
-     * @return the contents read out of the given reader.
-     *
-     * @throws IOException if the contents could not be read out from the
-     *         reader.
-     */
-    public static final String readFully(Reader rdr) throws IOException {
-        return readFully(rdr, BUF_SIZE);
-    }
-
-    /**
-     * Read from reader till EOF.
-     *
-     * @param rdr the reader from which to read.
-     * @param bufferSize the buffer size to use when reading.
-     *
-     * @return the contents read out of the given reader.
-     *
-     * @throws IOException if the contents could not be read out from the
-     *         reader.
-     */
-    public static final String readFully(Reader rdr, int bufferSize)
-        throws IOException {
-        if (bufferSize <= 0) {
-            throw new IllegalArgumentException("Buffer size must be greater "
-                                               + "than 0");
-        }
-        final char[] buffer = new char[bufferSize];
-        int bufferLength = 0;
-        StringBuffer textBuffer = null;
-        while (bufferLength != -1) {
-            bufferLength = rdr.read(buffer);
-            if (bufferLength > 0) {
-                textBuffer = (textBuffer == null) ? new StringBuffer() : textBuffer;
-                textBuffer.append(new String(buffer, 0, bufferLength));
-            }
-        }
-        return (textBuffer == null) ? null : textBuffer.toString();
-    }
-
-    /**
-     * This was originally an emulation of File.createNewFile for JDK 1.1,
-     * but it is now implemented using that method (Ant 1.6.3 onwards).
-     *
-     * <p>This method has historically <strong>not</strong> guaranteed that the
-     * operation was atomic. In its current implementation it is.
-     *
-     * @param f the file to be created.
-     * @return true if the file did not exist already.
-     * @throws IOException on error.
-     * @since Ant 1.5
-     */
-    public boolean createNewFile(File f) throws IOException {
-        return f.createNewFile();
-    }
-
-    /**
-     * Create a new file, optionally creating parent directories.
-     *
-     * @param f the file to be created.
-     * @param mkdirs <code>boolean</code> whether to create parent directories.
-     * @return true if the file did not exist already.
-     * @throws IOException on error.
-     * @since Ant 1.6.3
-     */
-    public boolean createNewFile(File f, boolean mkdirs) throws IOException {
-        File parent = f.getParentFile();
-        if (mkdirs && !(parent.exists())) {
-            parent.mkdirs();
-        }
-        return f.createNewFile();
-    }
+//    /**
+//     * Returns a VMS String representation of a <code>File</code> object.
+//     * This is useful since the JVM by default internally converts VMS paths
+//     * to Unix style.
+//     * The returned String is always an absolute path.
+//     *
+//     * @param f The <code>File</code> to get the VMS path for.
+//     * @return The absolute VMS path to <code>f</code>.
+//     */
+//    public String toVMSPath(File f) {
+//        // format: "DEVICE:[DIR.SUBDIR]FILE"
+//        String osPath;
+//        String path = normalize(f.getAbsolutePath()).getPath();
+//        String name = f.getName();
+//        boolean isAbsolute = path.charAt(0) == File.separatorChar;
+//        // treat directories specified using .DIR syntax as files
+//        boolean isDirectory = f.isDirectory()
+//            && !name.regionMatches(true, name.length() - 4, ".DIR", 0, 4);
+//
+//        String device = null;
+//        StringBuffer directory = null;
+//        String file = null;
+//
+//        int index = 0;
+//
+//        if (isAbsolute) {
+//            index = path.indexOf(File.separatorChar, 1);
+//            if (index == -1) {
+//                return path.substring(1) + ":[000000]";
+//            } else {
+//                device = path.substring(1, index++);
+//            }
+//        }
+//        if (isDirectory) {
+//            directory = new StringBuffer(path.substring(index).
+//                                         replace(File.separatorChar, '.'));
+//        } else {
+//            int dirEnd =
+//                path.lastIndexOf(File.separatorChar, path.length());
+//            if (dirEnd == -1 || dirEnd < index) {
+//                file = path.substring(index);
+//            } else {
+//                directory = new StringBuffer(path.substring(index, dirEnd).
+//                                             replace(File.separatorChar, '.'));
+//                index = dirEnd + 1;
+//                if (path.length() > index) {
+//                    file = path.substring(index);
+//                }
+//            }
+//        }
+//        if (!isAbsolute && directory != null) {
+//            directory.insert(0, '.');
+//        }
+//        osPath = ((device != null) ? device + ":" : "")
+//            + ((directory != null) ? "[" + directory + "]" : "")
+//            + ((file != null) ? file : "");
+//        return osPath;
+//    }
+
+//    /**
+//     * Create a temporary file in a given directory.
+//     *
+//     * <p>The file denoted by the returned abstract pathname did not
+//     * exist before this method was invoked, any subsequent invocation
+//     * of this method will yield a different file name.</p>
+//     * <p>
+//     * The filename is prefixNNNNNsuffix where NNNN is a random number.
+//     * </p>
+//     * <p>This method is different from File.createTempFile() of JDK 1.2
+//     * as it doesn't create the file itself.  It uses the location pointed
+//     * to by java.io.tmpdir when the parentDir attribute is null.</p>
+//     *
+//     * @param prefix prefix before the random number.
+//     * @param suffix file extension; include the '.'.
+//     * @param parentDir Directory to create the temporary file in;
+//     * java.io.tmpdir used if not specified.
+//     *
+//     * @return a File reference to the new temporary file.
+//     * @since Ant 1.5
+//     */
+//    public File createTempFile(String prefix, String suffix, File parentDir) {
+//        File result = null;
+//        String parent = (parentDir == null)
+//            ? System.getProperty("java.io.tmpdir")
+//            : parentDir.getPath();
+//
+//        DecimalFormat fmt = new DecimalFormat("#####");
+//        synchronized (rand) {
+//            do {
+//                result = new File(parent,
+//                                  prefix + fmt.format(Math.abs(rand.nextInt()))
+//                                  + suffix);
+//            } while (result.exists());
+//        }
+//        return result;
+//    }
+
+//    /**
+//     * Compares the contents of two files.
+//     *
+//     * @param f1 the file whose content is to be compared.
+//     * @param f2 the other file whose content is to be compared.
+//     *
+//     * @return true if the content of the files is the same.
+//     *
+//     * @throws IOException if the files cannot be read.
+//     */
+//    public boolean contentEquals(File f1, File f2) throws IOException {
+//        return contentEquals(f1, f2, false);
+//    }
+
+//    /**
+//     * Compares the contents of two files.
+//     *
+//     * @param f1 the file whose content is to be compared.
+//     * @param f2 the other file whose content is to be compared.
+//     * @param textfile true if the file is to be treated as a text file and
+//     *        differences in kind of line break are to be ignored.
+//     *
+//     * @return true if the content of the files is the same.
+//     *
+//     * @throws IOException if the files cannot be read.
+//     * @since Ant 1.6.3
+//     */
+//    public boolean contentEquals(File f1, File f2, boolean textfile) throws IOException {
+//        if (f1.exists() != f2.exists()) {
+//            return false;
+//        }
+//        if (!f1.exists()) {
+//            // two not existing files are equal
+//            return true;
+//        }
+//        // should the following two be switched?  If f1 and f2 refer to the same file,
+//        // isn't their content equal regardless of whether that file is a directory?
+//        if (f1.isDirectory() || f2.isDirectory()) {
+//            // don't want to compare directory contents for now
+//            return false;
+//        }
+//        if (fileNameEquals(f1, f2)) {
+//            // same filename => true
+//            return true;
+//        }
+//        return textfile ? textEquals(f1, f2) : binaryEquals(f1, f2);
+//    }
+
+//    /**
+//     * Binary compares the contents of two files.
+//     * <p>
+//     * simple but sub-optimal comparision algorithm. written for working
+//     * rather than fast. Better would be a block read into buffers followed
+//     * by long comparisions apart from the final 1-7 bytes.
+//     * </p>
+//     *
+//     * @param f1 the file whose content is to be compared.
+//     * @param f2 the other file whose content is to be compared.
+//     * @return true if the content of the files is the same.
+//     * @throws IOException if the files cannot be read.
+//     */
+//    private boolean binaryEquals(File f1, File f2) throws IOException {
+//        if (f1.length() != f2.length()) {
+//            // different size =>false
+//            return false;
+//        }
+//
+//        InputStream in1 = null;
+//        InputStream in2 = null;
+//        try {
+//            in1 = new BufferedInputStream(new FileInputStream(f1));
+//            in2 = new BufferedInputStream(new FileInputStream(f2));
+//
+//            int expectedByte = in1.read();
+//            while (expectedByte != -1) {
+//                if (expectedByte != in2.read()) {
+//                    return false;
+//                }
+//                expectedByte = in1.read();
+//            }
+//            if (in2.read() != -1) {
+//                return false;
+//            }
+//            return true;
+//        } finally {
+//            close(in1);
+//            close(in2);
+//        }
+//    }
+
+//    /**
+//     * Text compares the contents of two files.
+//     *
+//     * Ignores different kinds of line endings.
+//     *
+//     * @param f1 the file whose content is to be compared.
+//     * @param f2 the other file whose content is to be compared.
+//     * @return true if the content of the files is the same.
+//     * @throws IOException if the files cannot be read.
+//     */
+//    private boolean textEquals(File f1, File f2) throws IOException {
+//        BufferedReader in1 = null;
+//        BufferedReader in2 = null;
+//        try {
+//            in1 = new BufferedReader(new FileReader(f1));
+//            in2 = new BufferedReader(new FileReader(f2));
+//
+//            String expected = in1.readLine();
+//            while (expected != null) {
+//                if (!expected.equals(in2.readLine())) {
+//                    return false;
+//                }
+//                expected = in1.readLine();
+//            }
+//            if (in2.readLine() != null) {
+//                return false;
+//            }
+//            return true;
+//        } finally {
+//            close(in1);
+//            close(in2);
+//        }
+//    }
+
+//    /**
+//     * This was originally an emulation of {@link File#getParentFile} for JDK 1.1,
+//     * but it is now implemented using that method (Ant 1.6.3 onwards).
+//     * @param f the file whose parent is required.
+//     * @return the given file's parent, or null if the file does not have a
+//     *         parent.
+//     * @since 1.10
+//     */
+//    public File getParentFile(File f) {
+//        return (f == null) ? null : f.getParentFile();
+//    }
+
+//    /**
+//     * Read from reader till EOF.
+//     * @param rdr the reader from which to read.
+//     * @return the contents read out of the given reader.
+//     *
+//     * @throws IOException if the contents could not be read out from the
+//     *         reader.
+//     */
+//    public static final String readFully(Reader rdr) throws IOException {
+//        return readFully(rdr, BUF_SIZE);
+//    }
+
+//    /**
+//     * Read from reader till EOF.
+//     *
+//     * @param rdr the reader from which to read.
+//     * @param bufferSize the buffer size to use when reading.
+//     *
+//     * @return the contents read out of the given reader.
+//     *
+//     * @throws IOException if the contents could not be read out from the
+//     *         reader.
+//     */
+//    public static final String readFully(Reader rdr, int bufferSize)
+//        throws IOException {
+//        if (bufferSize <= 0) {
+//            throw new IllegalArgumentException("Buffer size must be greater "
+//                                               + "than 0");
+//        }
+//        final char[] buffer = new char[bufferSize];
+//        int bufferLength = 0;
+//        StringBuffer textBuffer = null;
+//        while (bufferLength != -1) {
+//            bufferLength = rdr.read(buffer);
+//            if (bufferLength > 0) {
+//                textBuffer = (textBuffer == null) ? new StringBuffer() : textBuffer;
+//                textBuffer.append(new String(buffer, 0, bufferLength));
+//            }
+//        }
+//        return (textBuffer == null) ? null : textBuffer.toString();
+//    }
+
+//    /**
+//     * This was originally an emulation of File.createNewFile for JDK 1.1,
+//     * but it is now implemented using that method (Ant 1.6.3 onwards).
+//     *
+//     * <p>This method has historically <strong>not</strong> guaranteed that the
+//     * operation was atomic. In its current implementation it is.
+//     *
+//     * @param f the file to be created.
+//     * @return true if the file did not exist already.
+//     * @throws IOException on error.
+//     * @since Ant 1.5
+//     */
+//    public boolean createNewFile(File f) throws IOException {
+//        return f.createNewFile();
+//    }
+
+//    /**
+//     * Create a new file, optionally creating parent directories.
+//     *
+//     * @param f the file to be created.
+//     * @param mkdirs <code>boolean</code> whether to create parent directories.
+//     * @return true if the file did not exist already.
+//     * @throws IOException on error.
+//     * @since Ant 1.6.3
+//     */
+//    public boolean createNewFile(File f, boolean mkdirs) throws IOException {
+//        File parent = f.getParentFile();
+//        if (mkdirs && !(parent.exists())) {
+//            parent.mkdirs();
+//        }
+//        return f.createNewFile();
+//    }
 
     /**
      * Checks whether a given file is a symbolic link.
@@ -1197,280 +1197,280 @@ public class FileUtils {
         return (p.startsWith(l)) ? p.substring(l.length()) : p;
     }
 
-    /**
-     * Constructs a <code>file:</code> URI that represents the
-     * external form of the given pathname.
-     *
-     * <p>Will be an absolute URI if the given path is absolute.</p>
-     *
-     * <p>This code doesn't handle non-ASCII characters properly.</p>
-     *
-     * @param path the path in the local file system.
-     * @return the URI version of the local path.
-     * @since Ant 1.6
-     */
-    public String toURI(String path) {
-        boolean isDir = (new File(path)).isDirectory();
-
-        StringBuffer sb = new StringBuffer("file:");
-
-        // catch exception if normalize thinks this is not an absolute path
-        try {
-            path = normalize(path).getAbsolutePath();
-            sb.append("//");
-            // add an extra slash for filesystems with drive-specifiers
-            if (!path.startsWith(File.separator)) {
-                sb.append("/");
-            }
-        } catch (BuildException e) {
-            // relative path
-        }
-
-        path = path.replace('\\', '/');
-
-        CharacterIterator iter = new StringCharacterIterator(path);
-        for (char c = iter.first(); c != CharacterIterator.DONE;
-             c = iter.next()) {
-            if (c < 256 && isSpecial[c]) {
-                sb.append('%');
-                sb.append(escapedChar1[c]);
-                sb.append(escapedChar2[c]);
-            } else {
-                sb.append(c);
-            }
-        }
-        if (isDir && !path.endsWith("/")) {
-            sb.append('/');
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Constructs a file path from a <code>file:</code> URI.
-     *
-     * <p>Will be an absolute path if the given URI is absolute.</p>
-     *
-     * <p>Swallows '%' that are not followed by two characters,
-     * doesn't deal with non-ASCII characters.</p>
-     *
-     * @param uri the URI designating a file in the local filesystem.
-     * @return the local file system path for the file.
-     * @since Ant 1.6
-     */
-    public String fromURI(String uri) {
-        String path = Locator.fromURI(uri);
-
-        // catch exception if normalize thinks this is not an absolute path
-        try {
-            path = normalize(path).getAbsolutePath();
-        } catch (BuildException e) {
-            // relative path
-        }
-        return path;
-    }
-
-    /**
-     * Compares two filenames.
-     *
-     * <p>Unlike java.io.File#equals this method will try to compare
-     * the absolute paths and &quot;normalize&quot; the filenames
-     * before comparing them.</p>
-     *
-     * @param f1 the file whose name is to be compared.
-     * @param f2 the other file whose name is to be compared.
-     *
-     * @return true if the file are for the same file.
-     *
-     * @since Ant 1.5.3
-     */
-    public boolean fileNameEquals(File f1, File f2) {
-        return normalize(f1.getAbsolutePath())
-            .equals(normalize(f2.getAbsolutePath()));
-    }
-
-    /**
-     * Renames a file, even if that involves crossing file system boundaries.
-     *
-     * <p>This will remove <code>to</code> (if it exists), ensure that
-     * <code>to</code>'s parent directory exists and move
-     * <code>from</code>, which involves deleting <code>from</code> as
-     * well.</p>
-     *
-     * @param from the file to move.
-     * @param to the new file name.
-     *
-     * @throws IOException if anything bad happens during this
-     * process.  Note that <code>to</code> may have been deleted
-     * already when this happens.
-     *
-     * @since Ant 1.6
-     */
-    public void rename(File from, File to) throws IOException {
-        if (to.exists() && !to.delete()) {
-            throw new IOException("Failed to delete " + to
-                                  + " while trying to rename " + from);
-        }
-        File parent = to.getParentFile();
-        if (parent != null && !parent.exists() && !parent.mkdirs()) {
-            throw new IOException("Failed to create directory " + parent
-                                  + " while trying to rename " + from);
-        }
-        if (!from.renameTo(to)) {
-            copyFile(from, to);
-            if (!from.delete()) {
-                throw new IOException("Failed to delete " + from
-                                      + " while trying to rename it.");
-            }
-        }
-    }
-
-    /**
-     * Get the granularity of file timestamps.
-     * The choice is made based on OS, which is incorrect--it should really be
-     * by filesystem. We do not have an easy way to probe for file systems,
-     * however.
-     * @return the difference, in milliseconds, which two file timestamps must have
-     * in order for the two files to be given a creation order.
-     */
-    public long getFileTimestampGranularity() {
-        return onDos
-            ? FAT_FILE_TIMESTAMP_GRANULARITY : UNIX_FILE_TIMESTAMP_GRANULARITY;
-    }
-
-    /**
-     * Returns true if the source is older than the dest.
-     * If the dest file does not exist, then the test returns false; it is
-     * implicitly not up do date.
-     * @param source source file (should be the older).
-     * @param dest dest file (should be the newer).
-     * @param granularity an offset added to the source time.
-     * @return true if the source is older than the dest after accounting
-     *              for granularity.
-     * @since Ant 1.6.3
-     */
-    public boolean isUpToDate(File source, File dest, long granularity) {
-        //do a check for the destination file existing
-        if (!dest.exists()) {
-            //if it does not, then the file is not up to date.
-            return false;
-        }
-        long sourceTime = source.lastModified();
-        long destTime = dest.lastModified();
-        return isUpToDate(sourceTime, destTime, granularity);
-    }
-
-
-    /**
-     * Returns true if the source is older than the dest.
-     * @param source source file (should be the older).
-     * @param dest dest file (should be the newer).
-     * @return true if the source is older than the dest, taking the granularity into account.
-     * @since Ant 1.6.3
-     */
-    public boolean isUpToDate(File source, File dest) {
-        return isUpToDate(source, dest, getFileTimestampGranularity());
-    }
-
-    /**
-     * Compare two timestamps for being up to date using
-     * the specified granularity.
-     *
-     * @param sourceTime timestamp of source file.
-     * @param destTime timestamp of dest file.
-     * @param granularity os/filesys granularity.
-     * @return true if the dest file is considered up to date.
-     */
-    public boolean isUpToDate(long sourceTime, long destTime, long granularity) {
-        if (destTime == -1) {
-            return false;
-        }
-        return destTime >= sourceTime + granularity;
-    }
-
-    /**
-     * Compare two timestamps for being up to date using the
-     * current granularity.
-     *
-     * @param sourceTime  timestamp of source file.
-     * @param destTime    timestamp of dest file.
-     * @return true if the dest file is considered up to date.
-     */
-    public boolean isUpToDate(long sourceTime, long destTime) {
-        return isUpToDate(sourceTime, destTime, getFileTimestampGranularity());
-    }
-
-    /**
-     * Close a Writer without throwing any exception if something went wrong.
-     * Do not attempt to close it if the argument is null.
-     * @param device output writer, can be null.
-     */
-    public static void close(Writer device) {
-        if (device != null) {
-            try {
-                device.close();
-            } catch (IOException ioex) {
-                //ignore
-            }
-        }
-    }
-
-    /**
-     * Close a stream without throwing any exception if something went wrong.
-     * Do not attempt to close it if the argument is null.
-     *
-     * @param device Reader, can be null.
-     */
-    public static void close(Reader device) {
-        if (device != null) {
-            try {
-                device.close();
-            } catch (IOException ioex) {
-                //ignore
-            }
-        }
-    }
-
-    /**
-     * Close a stream without throwing any exception if something went wrong.
-     * Do not attempt to close it if the argument is null.
-     *
-     * @param device stream, can be null.
-     */
-    public static void close(OutputStream device) {
-        if (device != null) {
-            try {
-                device.close();
-            } catch (IOException ioex) {
-                //ignore
-            }
-        }
-    }
-
-    /**
-     * Close a stream without throwing any exception if something went wrong.
-     * Do not attempt to close it if the argument is null.
-     *
-     * @param device stream, can be null.
-     */
-    public static void close(InputStream device) {
-        if (device != null) {
-            try {
-                device.close();
-            } catch (IOException ioex) {
-                //ignore
-            }
-        }
-    }
-
-    /**
-     * Delete the file with {@link File#delete()} if the argument is not null.
-     * Do nothing on a null argument.
-     * @param file file to delete.
-     */
-    public static void delete(File file) {
-        if (file != null) {
-            file.delete();
-        }
-    }
+//    /**
+//     * Constructs a <code>file:</code> URI that represents the
+//     * external form of the given pathname.
+//     *
+//     * <p>Will be an absolute URI if the given path is absolute.</p>
+//     *
+//     * <p>This code doesn't handle non-ASCII characters properly.</p>
+//     *
+//     * @param path the path in the local file system.
+//     * @return the URI version of the local path.
+//     * @since Ant 1.6
+//     */
+//    public String toURI(String path) {
+//        boolean isDir = (new File(path)).isDirectory();
+//
+//        StringBuffer sb = new StringBuffer("file:");
+//
+//        // catch exception if normalize thinks this is not an absolute path
+//        try {
+//            path = normalize(path).getAbsolutePath();
+//            sb.append("//");
+//            // add an extra slash for filesystems with drive-specifiers
+//            if (!path.startsWith(File.separator)) {
+//                sb.append("/");
+//            }
+//        } catch (BuildException e) {
+//            // relative path
+//        }
+//
+//        path = path.replace('\\', '/');
+//
+//        CharacterIterator iter = new StringCharacterIterator(path);
+//        for (char c = iter.first(); c != CharacterIterator.DONE;
+//             c = iter.next()) {
+//            if (c < 256 && isSpecial[c]) {
+//                sb.append('%');
+//                sb.append(escapedChar1[c]);
+//                sb.append(escapedChar2[c]);
+//            } else {
+//                sb.append(c);
+//            }
+//        }
+//        if (isDir && !path.endsWith("/")) {
+//            sb.append('/');
+//        }
+//        return sb.toString();
+//    }
+
+//    /**
+//     * Constructs a file path from a <code>file:</code> URI.
+//     *
+//     * <p>Will be an absolute path if the given URI is absolute.</p>
+//     *
+//     * <p>Swallows '%' that are not followed by two characters,
+//     * doesn't deal with non-ASCII characters.</p>
+//     *
+//     * @param uri the URI designating a file in the local filesystem.
+//     * @return the local file system path for the file.
+//     * @since Ant 1.6
+//     */
+//    public String fromURI(String uri) {
+//        String path = Locator.fromURI(uri);
+//
+//        // catch exception if normalize thinks this is not an absolute path
+//        try {
+//            path = normalize(path).getAbsolutePath();
+//        } catch (BuildException e) {
+//            // relative path
+//        }
+//        return path;
+//    }
+
+//    /**
+//     * Compares two filenames.
+//     *
+//     * <p>Unlike java.io.File#equals this method will try to compare
+//     * the absolute paths and &quot;normalize&quot; the filenames
+//     * before comparing them.</p>
+//     *
+//     * @param f1 the file whose name is to be compared.
+//     * @param f2 the other file whose name is to be compared.
+//     *
+//     * @return true if the file are for the same file.
+//     *
+//     * @since Ant 1.5.3
+//     */
+//    public boolean fileNameEquals(File f1, File f2) {
+//        return normalize(f1.getAbsolutePath())
+//            .equals(normalize(f2.getAbsolutePath()));
+//    }
+
+//    /**
+//     * Renames a file, even if that involves crossing file system boundaries.
+//     *
+//     * <p>This will remove <code>to</code> (if it exists), ensure that
+//     * <code>to</code>'s parent directory exists and move
+//     * <code>from</code>, which involves deleting <code>from</code> as
+//     * well.</p>
+//     *
+//     * @param from the file to move.
+//     * @param to the new file name.
+//     *
+//     * @throws IOException if anything bad happens during this
+//     * process.  Note that <code>to</code> may have been deleted
+//     * already when this happens.
+//     *
+//     * @since Ant 1.6
+//     */
+//    public void rename(File from, File to) throws IOException {
+//        if (to.exists() && !to.delete()) {
+//            throw new IOException("Failed to delete " + to
+//                                  + " while trying to rename " + from);
+//        }
+//        File parent = to.getParentFile();
+//        if (parent != null && !parent.exists() && !parent.mkdirs()) {
+//            throw new IOException("Failed to create directory " + parent
+//                                  + " while trying to rename " + from);
+//        }
+//        if (!from.renameTo(to)) {
+//            copyFile(from, to);
+//            if (!from.delete()) {
+//                throw new IOException("Failed to delete " + from
+//                                      + " while trying to rename it.");
+//            }
+//        }
+//    }
+
+//    /**
+//     * Get the granularity of file timestamps.
+//     * The choice is made based on OS, which is incorrect--it should really be
+//     * by filesystem. We do not have an easy way to probe for file systems,
+//     * however.
+//     * @return the difference, in milliseconds, which two file timestamps must have
+//     * in order for the two files to be given a creation order.
+//     */
+//    public long getFileTimestampGranularity() {
+//        return onDos
+//            ? FAT_FILE_TIMESTAMP_GRANULARITY : UNIX_FILE_TIMESTAMP_GRANULARITY;
+//    }
+
+//    /**
+//     * Returns true if the source is older than the dest.
+//     * If the dest file does not exist, then the test returns false; it is
+//     * implicitly not up do date.
+//     * @param source source file (should be the older).
+//     * @param dest dest file (should be the newer).
+//     * @param granularity an offset added to the source time.
+//     * @return true if the source is older than the dest after accounting
+//     *              for granularity.
+//     * @since Ant 1.6.3
+//     */
+//    public boolean isUpToDate(File source, File dest, long granularity) {
+//        //do a check for the destination file existing
+//        if (!dest.exists()) {
+//            //if it does not, then the file is not up to date.
+//            return false;
+//        }
+//        long sourceTime = source.lastModified();
+//        long destTime = dest.lastModified();
+//        return isUpToDate(sourceTime, destTime, granularity);
+//    }
+
+
+//    /**
+//     * Returns true if the source is older than the dest.
+//     * @param source source file (should be the older).
+//     * @param dest dest file (should be the newer).
+//     * @return true if the source is older than the dest, taking the granularity into account.
+//     * @since Ant 1.6.3
+//     */
+//    public boolean isUpToDate(File source, File dest) {
+//        return isUpToDate(source, dest, getFileTimestampGranularity());
+//    }
+
+//    /**
+//     * Compare two timestamps for being up to date using
+//     * the specified granularity.
+//     *
+//     * @param sourceTime timestamp of source file.
+//     * @param destTime timestamp of dest file.
+//     * @param granularity os/filesys granularity.
+//     * @return true if the dest file is considered up to date.
+//     */
+//    public boolean isUpToDate(long sourceTime, long destTime, long granularity) {
+//        if (destTime == -1) {
+//            return false;
+//        }
+//        return destTime >= sourceTime + granularity;
+//    }
+
+//    /**
+//     * Compare two timestamps for being up to date using the
+//     * current granularity.
+//     *
+//     * @param sourceTime  timestamp of source file.
+//     * @param destTime    timestamp of dest file.
+//     * @return true if the dest file is considered up to date.
+//     */
+//    public boolean isUpToDate(long sourceTime, long destTime) {
+//        return isUpToDate(sourceTime, destTime, getFileTimestampGranularity());
+//    }
+
+//    /**
+//     * Close a Writer without throwing any exception if something went wrong.
+//     * Do not attempt to close it if the argument is null.
+//     * @param device output writer, can be null.
+//     */
+//    public static void close(Writer device) {
+//        if (device != null) {
+//            try {
+//                device.close();
+//            } catch (IOException ioex) {
+//                //ignore
+//            }
+//        }
+//    }
+
+//    /**
+//     * Close a stream without throwing any exception if something went wrong.
+//     * Do not attempt to close it if the argument is null.
+//     *
+//     * @param device Reader, can be null.
+//     */
+//    public static void close(Reader device) {
+//        if (device != null) {
+//            try {
+//                device.close();
+//            } catch (IOException ioex) {
+//                //ignore
+//            }
+//        }
+//    }
+
+//    /**
+//     * Close a stream without throwing any exception if something went wrong.
+//     * Do not attempt to close it if the argument is null.
+//     *
+//     * @param device stream, can be null.
+//     */
+//    public static void close(OutputStream device) {
+//        if (device != null) {
+//            try {
+//                device.close();
+//            } catch (IOException ioex) {
+//                //ignore
+//            }
+//        }
+//    }
+
+//    /**
+//     * Close a stream without throwing any exception if something went wrong.
+//     * Do not attempt to close it if the argument is null.
+//     *
+//     * @param device stream, can be null.
+//     */
+//    public static void close(InputStream device) {
+//        if (device != null) {
+//            try {
+//                device.close();
+//            } catch (IOException ioex) {
+//                //ignore
+//            }
+//        }
+//    }
+
+//    /**
+//     * Delete the file with {@link File#delete()} if the argument is not null.
+//     * Do nothing on a null argument.
+//     * @param file file to delete.
+//     */
+//    public static void delete(File file) {
+//        if (file != null) {
+//            file.delete();
+//        }
+//    }
 }
 
